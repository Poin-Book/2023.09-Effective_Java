# 불필요한 객체 생성을 피하라

> 작성자: 루키

## 목차
- [불필요한 객체 생성을 피하라](#불필요한-객체-생성을-피하라)
  - [목차](#목차)
  - [본문](#본문)
    - [1. 들어가며](#1-들어가며)
    - [2. 재사용을 해야하는 경우](#2-재사용을-해야하는-경우)
    - [3. 불필요한 객체를 만들어내거나 그 문제를 해결한 경우](#3-불필요한-객체를-만들어내거나-그-문제를-해결한-경우)
    - [4. 끝내며](#4-끝내며)
   
## 본문

### 1. 들어가며

> 요약: 객체는 재사용하는 것이 좋은 경우가 많다
> 
- 위 요약문은 모든 사람이 쉽게 공감할 것이다.
- 왜? → 객체를 재사용 한다면 메모리도 절약하고 생성시 소모하는 시간을 최소화 하기 때문에
- 하지만 여기서 약간 비틀어서 생각한다면 다음과 같은 의문이 들 것이다.

<aside>
❓ 과연 모든 객체가 재사용이 가능할까?

</aside>

- 결론 부터 써보자면 그렇지 않다.
    - 조금만 생각해보면 객체의 상태나 맴버 변수의 값이 런타임에서 바뀌게 된다면
    - 해당 객체를 재사용하는 것은 굉장히 위험한 생각이다.
- 가장 간단한 재사용 예시를 들자면 다음과 같다
    
    ```java
    String s = "string";
    ```
    
    - 어? 그냥 문자열 타입을 뿐인데 왜 객체 재사용인가요?
    - 우리는 String 타입에 new 키워드가 먹힌다는 것을 떠올릴 필요가 있다.
        
        ```java
        String s = new String("string");
        ```
        
    - 하지만 어느 그 누구도 new 키워드로 String 객체를 새로 생성하지 않는다.
    - 왜? → String Constant pool 이라는 메모리 영역에 담아두기 때문이다.
    - 그냥 String 리터럴로 변수를 초기화 한다면 같은 객체를 재사용하는 것이 보장된다.

### 2. 재사용을 해야하는 경우

> 그렇다면 객체를 언제 어떠한 경우에 재사용을 해야할까?
> 
1. 불변 클래스
    - 생성자 대신 정적 팩토리 메서드를 제공하는 클래스
    - Item 1에서 보았듯이 이 클래스는 객체를 새롭게 만들지 않는다.
    - 예시
        
        ```java
        Boolean.valueOf("TRUE"); //true값을 가지는 Boolean
        ```
        
        - 이 정적 팩토리 메서드는 Boolean 이라는 래퍼 클래스를 반환하는데
        - 해당 래퍼 클래스를 새로 생성하지 않고 재사용 한다.
    - 이렇게 불변인 클래스는 재사용해도 문제가 없다 (명백하게)
2. 생성 비용이 굉장히 비싼 클래스
    - 이 경우는 생성 비용이 (주로 시간) 굉장히 비싼 클래스를 반복해서 사용해야하는 경우를 이야기 한다
    - 예를 들어서 우리가 BE개발시 많이 사용하는 정규표현식을 들 수 있다.
        
        ```java
        static boolean regexCheck(String s) {
        	return s.matches("Regex String");
        }
        ```
        
        - 이 방식의 문제는 String.matches를 사용하는 것에 있다.
        - 물론 가장 간단한 방법이지만 반복 빈도가 높다면 그리 권장하지 않는다.
        - 왜? → String.matches라는 메서드를 까보면 된다.
            
            ```java
            public boolean matches(String regex) {
              return Pattern.matches(regex, this);
            }
            
            //다시 Pattern.matches를 까보면...
            public static boolean matches(String regex, CharSequence input) {
               Pattern p = Pattern.compile(regex);
               Matcher m = p.matcher(input);
               return m.matches();
            }
            
            //또다시 Pattern.compile을 까보면...
            public static Pattern compile(String regex) {
              return new Pattern(regex, 0);
            	//Pattern 객체를 new 키워드로 새로 생성한다.
            }
            ```
            
        - 여기서 만드는 Pattern 인스턴스는 일회용으로 사용 후 바로 가비지 컬랙터에 의해서 수거된다
        - 따라서 성능을 개선하기 위해서는 다음과 같이 해야한다.
            
            ```java
            private class RegexUtil {
            	private static final Pattern MATCHER = Pattern.compile("Regex String");
            
            	//... 생략
            }
            ```
            
        - 이런 방식을 캐싱하여 재사용 한다고 한다.
        - 그러면 이렇게 애써 캐싱해놨는데 객체를 한번도 call 하지 않으면 낭비 아닌가?
            - 그런 당신을 위해 지연 초기화라는 것이 있다
            - 다만… 쓸대없이 코드가 복잡해지기 때문에 그냥 캐싱해서 쓰는게 맞다.
            - 코드가 복잡해지는 것 대비 성능 향상이 크지 않기 때문
3. 런타임에 변경되지 않음이 확실한 가변 객체

### 3. 불필요한 객체를 만들어내거나 그 문제를 해결한 경우

> 어댑터(뷰) 패턴
> 
- 어댑터는 실제 작업은 뒷단에 위치한 객체에 위임하는 패턴이다.
- 따라서 뒷단 객체 하나만 관리하면 된다.
- 그렇다면 이거 하나 이외에는 관리할 상태가 없으므로 뒷단 객체당 하나의 어댑터만 있으면 충분하다.
- 예시
    - Map 인터페이스의 KeySet메서드
        - Map 객체의 ket 세트를 반환하는 메서드
        - 그렇다면 반환하는 Set 객체는 항상 같을까 다를까
        - 이것도 한번 코드를 까보자
            
            ![image](https://github.com/Poin-Book/2023.09-Effective_Java/assets/74547868/21514350-02e9-474e-b9b5-525275ba5ef1)

            
            - Map 인터페이스를 까서 들어가다 보면 다음과 같은 코드 라인을 볼 수 있다.
                
                ```java
                transient Set<K> keySet;
                ```
                
            - 자바독 해석 (위 코드 바로 위에 붙어있다)
                
                ```java
                이 각 필드는 처음 이 뷰를 요청할 때 해당 뷰의 인스턴스를 포함하도록 초기화됩니다. 
                뷰는 상태 비저장 상태이므로 **둘 이상 생성할 이유가 없습니다**.
                이 필드에 액세스하는 동안 수행되는 동기화가 없으므로, 
                이 필드를 사용하는 java.util.Map view 클래스에는 최종 필드가 아닌 필드(또는 외부 필드를 제외한 모든 필드)가 없습니다. 
                이 규칙을 준수하면 이 필드에 대한 레이스가 양호해집니다.
                또한 구현은 다음과 같이 필드를 한 번만 읽는 것이 중요합니다:
                ```
                
        - 그렇다 결국은 하나 생성해서 재사용하는 것이라고 받아들여도 될것이다.
        - 결국 해당 view를 호출할때 마다 새로운 Set을 생성하지 않고 또 만약 그렇게 하더라도 이득이 없다라는 소리다.

> 오토박싱
> 
- 흔히 래퍼 클래스라고 말하는 클래스들에 관한 내용이다.
- 오토박싱은 primitive type과 Wrapper type을 섞어서 쓸때 알아서 상호 변환을 해주는 기술
- 따라서 뭘 사용하든 차이가 거의 없도록 해주지만…
- 완전히 없애주지는 않는다. → 이게 성능과 직결된다
- 다음 코드를 생각해보자
    
    ```java
    private static long sum() {
    	Long sum = 0L;
    	for(long i = 0; i <= Integer.MAX_VALUE; i++) {
    		sum += i;
    	}
    
    	retirn sum;
    }
    ```
    
- 이게 도대체 뭔 문제냐 할 수 있겠지만
- 4번째 라인에서 for 문을 돌때 마다 인스턴스가 만들어진다
- 따라서 엄청난 자원 손실이 일어난다…

### 4. 끝내며

- 이번 아이탬은 “객체 생성은 비싸니까 피해야한다” 라고 이해하면 안된다
- 요즘 JVM은 굉장히 똑똑해서 작은 객체들을 가비지 컬랙터에서 회수하는 것은 문제가 안된다
- 추가로 객체를 생성해서 더 좋다면 기쁜 마음으로 생성하는 것이 맞다
- 바꿔말하면…
    - 엄청 무거운 객체가 아닌 이상에야 객체 생성을 피해야한다는 일념하에 객체 pool을 만드는 것을 피해야 한다.
    - pool을 사용하는 대표적인 경우가 JDBC Connection 객체일 것이다.
    - 이것은 굉장히 비싼 객체이므로 이렇게 하는 것이 맞지만
    - 일반적인 경우에서는 오히려 메모리 사용량이 올라가고 성능을 떨어뜨린다
        - API에서 가장 시간 소모가 큰 것이 DB 접근이라는 것을 떠올려 보자
    - 그래서 그냥 가벼운 객체들은 생성하고 사용이 끝나면 그냥 가비지 컬랙터에 처리를 맡겨버리는 것이 차라리 더 빠르다.
- 또한 아이탬 50에서 나오는 방어적 복사가 필요한 객체에는 재사용을 하면 안된다.
    - 왜냐하면 그러한 상황에서 재사용 해버리면 오히려 더 큰 문제가 발생할 수 있기 때문이다.
    - 방어적 복사에 실패한다면 버그와 보안구멍의 시한폭탄이 되기 때문…