# 인스턴스화를 막으려거든 private 생성자를 사용하라

> 작성자: 루카

- [인스턴스화를 막으려거든 private 생성자를 사용하라](#인스턴스화를-막으려거든-private-생성자를-사용하라)
  - [Static 메서드와 필드로만 구성된 클래스](#static-메서드와-필드로만-구성된-클래스)
  - [정적 유틸리티 클래스의 설계의도](#정적-유틸리티-클래스의-설계의도)
  - [private 생성자를 통해 클래스의 인스턴스화를 막을 수 있다](#private-생성자를-통해-클래스의-인스턴스화를-막을-수-있다)

## Static 메서드와 필드로만 구성된 클래스

개발을 하다보면 static 메서드와 필드로만 구성된 클래스가 필요한 경우가 있다. <br>
객체지향적인 설계는 아니지만, 다음과 같은 상황에 유용하다.

- 기본 타입 값이나 배열 관련 메서드들을 모아놓은 `유틸리티성 클래스의 설계`
  - java.lang.Math, java.util.Arrays
- 특정 인터페이스를 구현하는 객체를 생성해주는 static 메서드를 모아놓을 때
  - java.util.Collections
- `추가 상속을 방지하기 위한` final 클래스와 관련한 메서드를 모아놓을 때
  - java.util.Objects

## 정적 유틸리티 클래스의 설계의도

[목표]

- 인스턴스로 만들어 사용하지 않을 클래스
- 상속을 불가능하게 막고 싶은 클래스
- 다른 클래스에 의존하지 않는 클래스

[문제점]

- 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다.
  - 즉, 외부에서 생성자를 호출하지 못하도록 막을 수 없다.

## private 생성자를 통해 클래스의 인스턴스화를 막을 수 있다

```java
public class UtilityClass {
  // 기본 생성자가 만들어지는 것을 막는다. (인스턴스화 방지용)
  private UtilityClass() {
    throw new AssertionError();
  }

  // 나머지 코드 생략
  ...
}
```

위와 같이 명시적으로 private 생성자를 추가하면 얻을 수 있는 장/단점은 다음과 같다.

[장점]

1. 클래스 외부에서 생성자에 접근할 수 없다.
2. 상속을 불가능하게 한다.

   - 모든 생성자는 상위 클래스의 생성자를 호출해야 하는데, private 생성자는 호출할 수 없으므로 상속이 불가능하다.

[단점]

1. 상속이 불가능하다.
2. 리플렉션을 통해 private 생성자를 호출할 수 있다.

   - 리플렉션을 통해 private 생성자를 호출할 수 있으므로, 이를 방어하기 위해 생성자에서 예외를 던지는 것이 좋다.
   - 예시에서는 `AssertionError`를 던졌다.
     - 클래스 내부에서 실수라도 생성자를 호출하면 예외를 던지도록 하여 방어하는 효과도 있음
