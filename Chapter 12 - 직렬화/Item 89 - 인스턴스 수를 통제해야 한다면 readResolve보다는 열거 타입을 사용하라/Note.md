# **인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라**

> 작성자: 피터
> 

싱글턴으로 구현된 클래스는 인스턴스를 하나만 만들어지는 것을 보장한다.

하지만 클래스에 implements Serializable 을 추가하는 순간 더 이상 싱글턴이 아니게 된다.기본 직렬화를 쓰지 않더라도, 그리고 명시적인 readObject를 제공하더라도 소용없다. 어떤 readObject를 사용하든 이 클래스가 초기화될 때 만들어진 인스턴스와는 별개인 인스턴스를 반환하게 된다.

## readResolve

readResolve 메서드를 이용하면 readObject 메서드가 만든 인스턴스를 다른 것으로 대체할 수 있다. 즉 역직렬화 과정에서 만들어진 인스턴스 대신에 기존에 생성된 싱글톤 인스턴스를 반환하게 한다. 실제로 역직렬화 과정에서 자동으로 호출되는 readObject 메서드가 있더라도 readResolve 메서드에서 반환한 인스턴스로 대체된다. 이때 readObject 가 만들어낸 인스턴스는 가비지 컬렉션의 대상이 된다. 

### **Transient**

Transient는 객체의 필드 중에 직렬화 하지 않을 것들을 지정하기 위해 사용한다. 따라서 readResolve를 인스턴스 통제 목적으로 사용한다면 역직렬화로 만들어지는 객체는 실데이터가 필요가 없기 때문에 transient로 선언해야한다.그러지 않으면MutablePeriod 공격과 비슷한 방식으로 readResolve 메서드 실행 전에 역직렬화된 객체의 참조를 공격할 여지가 있다.

## Enum

열거 타입(enum)은 자바에서 선언한 상수 이외의 다른 객체 인스턴스가 존재하지 않음을 보장한다. 단, 이러한 보장은 리플렉션을 통한 **`AccessibleObject.setAccessible`** 메서드 같은 고급 기능을 악용한 경우에는 해당하지 않는다. 또한, 네이티브 코드 실행과 같은 특권을 가진 공격자에 의한 경우도 제외한다. 이런 상황에서는 모든 방어 메커니즘이 무력화될 수 있다.

## readResolve사용해야 할 때

직렬화 가능 인스턴스 통제 클래스를 작성해야 하는데, 컴파일타임에는 어떤 인스턴스가 있는지 알 수 없는 상황이라면 열거타입으로 표현이 불가능하기 때문에 이때 readResolve를 사용해야한다.

readResolve는 반드시 private이어야 한다. 

## 정리

인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용해야한다. 그럼에도 readResolve를 사용해야한다면 해당 클래스에서 모든 참조 타입 인스턴스 필드를 transient로 선언해야 한다.
