# 자바 직렬화의 대안을 찾으라

> 작성자: 다나

## 목차
- 직렬화
- 자바의 직렬화는 위험하다
- 가젯
- 역직렬화 폭탄
- 직렬화 회피 방법
- 핵심 정리

## **직렬화**

- 직렬화 : 자바가 객체를 바이트 스트림으로 인코딩
- 역직렬화 : 바이트 스트림으로부터 다시 객체의 상태로 변환하는 것
- 바이트 스트림 : 데이터의 흐름, 클라이언트와 서버같이 어떤 출발지와 목적지로 입출력하기 위한 통로
    - 자바에서 입력으로는 InputStream, 출력으로는 `OutputStream`
- 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 필요할 때 역직렬화하여 사용할 수 있다.
- 직렬화는 용량이 크다.
    - 직렬화는 객체에 저장된 데이터값 뿐만 아니라 타입 정보, 클래스 메타 정보를 가지고 있으므로 용량을 은근히 많이 차지한다.
    - 그래서 같은 정보를 직렬화로 저장하느냐 JSON으로 저장하느냐는 파일 용량 크기가 거의 2배 이상 차이가 난다.
    - 따라서 DB, Cache 등에 외부에 저장할때, 장기간 동안 저장하는 정보는 직렬화를 지양해야 된다.

### **자바의 직렬화는 위험하다.**

- 직렬화를 하고 나서 역직렬화를 할 때 문제가 된다.
    - 객체를 읽는 readObject 메서드는 클래스 패스에 존재하는 거의 모든 타입의 객체를 만들어낼 수 있다.
        - 반환 타입이 Object이다.
    - 바이트 스트림을 역직렬화하는 과정에서 해당 타입 안의 모든 코드를 수행할 수 있다.
        - 객체를 아예 불러올 수 있으므로 모든 코드를 수행할 수 있다
- 그렇기에 타입 전체가 전부 공격 범위에 들어가게 된다.
- 용량도 다른 포맷에 비해서 몇 배 이상의 크기를 가집니다
- 역직렬화 폭탄을 맞을 수 있다 .
    - 역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다.

### **가젯(gadget)**

- 가젯 : 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 하는 메서드
- 여러 가젯을 함께 사용하여 가젯 체인을 구성할 수도 있는데, 공격자가 기반 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 강력한 가젯 체인도 존재한다.
- 이러한 이유로 아주 신중하게 제작한 바이트 스트림만 역직렬화해야 한다.

## 역직렬화 폭탄

```java
static byte[] bomb() {
Set<Object> root = new HashSet<>();
Set<Object> s1 = root;
Set<Object> s2 = new HashSet<>();

for (int i=0; i < 100; i++) {
			Set<Object> t1 = new HashSet<>();
			Set<Object> t2 = new HashSet<>();
      t1.add("foo"); 
      s1.add(t1); s1.add(t2);
      s2.add(t1); s2.add(t2);
      s1 = t1; 
			s2 = t2;
  }
return serialize(root);
}

```

![image](https://github.com/Poin-Book/2023.09-Effective_Java/assets/85955988/c73168bf-1145-4e06-8427-ec63132a9ee1)


- 역직렬화 폭탄 : 역직렬화에 시간이 오래 걸리는 짧은 스트림
- 이러한 역직렬화 폭탄을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다.
- 이 객체 그래프는201개의 HashSet 인스턴스로 구성되며, 각각 3개 이하의 객체 참조를 갖는다.
- 스트림의 전체 크기는 5744바이트지만, 역직렬화는 태양이 식을 때까지도 끝나지 않는다.
    - 이유는 HashSet 인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산해야 하는 것이다.
    - 루트 HashSet에 담긴 두 원소는 다른 HashSet 2개씩을 원소로 갖는 HashSet이며, 반복문에 의해 구조가 깊이 100까지 만들어진다.
    - 따라서 HashSet을 역직렬화하려면 hashCode 메서드를 2^100 번 넘게 호출해야 한다.

## 직렬화 회피 방법

### **직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.**

- 객체 역직렬화 필터링(java.io.ObjectInputFilter)을 사용한다. 신뢰할 수 없는 데이터의 직렬화를 피할 수 없을 때 사용한다. 필터를 설치하여 특정 클래스를 직렬화할지 선택할 수 있다.

### **크로스-플랫폼 구조화된 데이터 표현**

- 자바 직렬화보다 훨씬 간단하다.
- 임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않고, 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다.
- 기본 타입 몇 개와 배열 타입만 지원한다.
- 이러한 간단한 추상화만으로 강력한 분산 시스템을 구축하기에 충분하고, 자바 직렬화의 문제를 회피할 수 있다.
- **대표적인 예로는 JSON과 프로토콜 버퍼이다.**
    - **JSON**
        - key - value 형식의 텍스트 형태
        - 브라우저와 서버의 통신용으로 설계됐으며, 자바스크립트용으로 만들어졌다.
        - 텍스트 기반이라 사람이 읽을 수 있으며 오직 데이터를 표현하는 데만 쓰인다.
    - **프로토콜 버퍼**
        - 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계됐으며, C++용으로 만들어졌다.
        - 이진 표현이라 효율이 훨씬 높다
        - 문서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다.
        - 이진 표현 뿐만 아니라 사람이 읽을 수 있는 텍스트 표현도 지원한다.

## **정리**

- 직렬화는 위험하니 피하자
- 직렬화 대신 JSON, 프로토콜 버퍼와 같은 대안을 사용하자
- 역직렬화 자체를 하지 않는 것이 좋고, 필요하다면 신뢰할 수 없는 데이터는 역직렬화하지 말자 (블랙리스트 방식보다는 화이트리스트 방식을 추천)
- 꼭 해야한다면 객체 역직렬화 필터링을 사용하되, 이마저도 모든 공격을 막아줄 수 없다는 것을 기억하자.
- 클래스가 직렬화를 지원하도록 만들지 말고, 꼭 필요하다면 많이 신경 써서 작성해야 한다.
