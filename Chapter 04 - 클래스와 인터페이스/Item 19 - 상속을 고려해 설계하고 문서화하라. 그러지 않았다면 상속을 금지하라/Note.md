# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

> 작성자: 캐슬

## 목차
1. **내부 메커니즘을 문서로 남기기**
2. **Protected 메서드(or 필드) 형태로 공개하기**
3. **Cloneable, Serializable 인터페이스의 상속**
4. **일반적인 구체 클래스**
5. **핵심정리**

## 내부 메커니즘을 문서로 남기기

---

메소드를 재정의 하면 어떤일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 상속 용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다.

- 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다.그런데 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API설명을 적시해야 한다.
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에  어떤 영향을 주는지도 담아야한다.
- 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다. (ex_ 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있다.)

API 문서 메서드 설명 끝에서 종종 “Implementation Requirements”로 시작하는 절이 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다.

***java.util.AbstractCollection***

> `public bolean remove(Object o)`
주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에 ‘Object.equals(o,e)가 참인 원소’ e가 하나이상 있다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면(즉 호출 결과가 이 컬렉션이 변경 됐다면) true를 반환한다.
Implementation Requirements : 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하자.
>

이 설명에 따르면 iterator 메서드를 재정의 하면 remove 메서드의 동작에 영향을 줌을 확실히 알 수 있다. iterator 메서드로 얻은 반복자의 동작이 remove 메서드의 동작에 주는 영향도 정확히 설명했다.

### @implSpec 태그
`@implSpec` 태그는 자바 8에서 처음 도입되어 9부터 본격적으로 사용되기 시작했다.

- 이 태그를 활성화 하려면 명령줄 매개 변수로 -tag  “implspec:a:Implementation Requirements:” 를 지정해주면 된다.

## Protected 메서드(or 필드) 형태로 공개하기

---

내부 매커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다. 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다. 드물게는 protected 필드 형태로 공개해야 할 수도 있다.

***java.util.AbstractList의 removeRange***
> `protected void removeRange(int fromIndex, int toIndex)`
fromIndex(포함) 부터 toIndex(미포함) 까지 모든 원소를 이 리스트에서 제거한다. toIndex 이후의 원소들은 (index 만큼씩)당겨진다. 이호출로 리스트는 ‘toIndex - fromIndex’ 만큼 짧아 진다.
이 리스트 혹은 이 리스트의 부분 리스트에 정의된 clear연산이 이 메서드를 호출한다. 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의 하려면 이 리스트와 부분 리스트의 clear 연산 성능을 크게 개선할 수 있다.
Implementation Requirements :  이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거할 때 까지 ListIterator.next와 ListIterator.remove를 반복 호출하도록 구현되었다. 주의: ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다.<br><br>
Parameters: <br>
fromIndex - 제거할 첫 원소의 인덱스<br>
toIndex - 제거할 마지막 원소의 다음 인덱스
>

- List 구현체의 최종 사용자는 removeRange메서드에 관심이 없다.
- 이 메서드를 제공한 이유는 단지 하위 클래스에서 부분리스트의 clear메서드를 고성능으로 만들기 쉽게 하기 위해서이다. → removeRange 메서드가 없다면 하위 클래스에서 clear메서드를 호출하면 제곱에 비례해 성능이 느려지거나 부분 리스트의 매커니즘을 바닥부터 새로 구현해야 했을 것이다.

### 상속용 클래스를 설계할 때 어떤 메서드를 proteted로 노출해야 하는가?

- 확실한 구분은 없다.
- 심사숙고해서 잘 예측해본다음, 실제 하위클래스를 만들어 시험해보는 것이 최선이다.
- preotected 메서드 하나하나가 내부구현에 해당하므로 그 수는 가능한 한 적어야한다.
- 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의 해야 한다.

> **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 유일하다.**
>
- 꼭 필요한 protected 맴버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 드러난다.
- 하위클래스를 여러개 만들 때까지 전혀 신경쓰이지 않는 protected 맴버는 사실 private이었어야 할 가능성이 크다.
- 검증에는 하위클래스 3개정도가 적당하다. → 이 중 하나는 제 3자가 작성해봐야한다.

### 상속용 클래스는 영원히 책임져야 한다.

- 상속용으로 설계한다면 내부 사용 패턴과, protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 한다.
- 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다.
- **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증하자.**

### 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.

- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- 이 규칙을 어기면 프로그램이 오동작 한다.
- 상위 클래스의 생성자가 하위클래스의 생성자보다 먼저 실행되므로 하위클래스에서 재정의 한 메서드가 하위 클래스의 생성자 보다 먼저 호출된다. 이때 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않는다.

***규칙을 어기는 코드***

```jsx
public class Super{
// 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
	public Super(){
		overrideMe();
	}
	public void overrideMe(){
	}
}
```

```jsx
public class Sub extends Super {

    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

- 이 프로그램은 instant를 두 번 출력하지 않고 첫 번째는 null을 호출한다. → 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe를 호출하기 때문
- 이 프로그램에서 final 상태의 필드가 두가지 이다.(정상적이라면 단 하나 뿐이여야 한다.)
- overrideMe에서 instant 객체의 메서드를 호출하려 한다면 상위 클래스의 생성자가 overrideMe를 호출할 때 NullPointerException을 던지게 된다.

> **private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출 가능하다.**
>

## Cloneable, Serializable 인터페이스의 상속

---

- Cloneable과 Serializable인터페이스는 상속용 설계의 어려움을 한층 더해준다.
- 둘중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다. → 그 클래스를 확장하려는 프로그래머에게 엄청난 부담
- 이 인터페이스들을 하위 클래스에서 구현하도록 하는 방법이 있다.

### clone, readObject 메서드

- clone 과 readObject 메서드는 생성자와 비슷한 효과를 낸다.(새로운 객체 생성)
- 상속용 클래스에서 Cloneable, Serializable을 구현할지 정해야 한다면, 이들을 구현할 때 따르는 제약도 생성자와 비슷하다는 점에 주의 해야한다.
- clone, readObject 모두 직, 간접적으로 재정의 가능 메서드를 호출해서는 안된다.
- readObject의 경우 하위 클래스의 상태가 미처 다 역직렬화 되기 전에 재정의한 메서드부터 호출한다.
- clone의 경우 하위 클래스의 상태가 미처 다 역직렬화 되기 전에 재정의한 메서드부터 호출하게 된다. → clone이 잘못되면 복제본 뿐아니라 원본 객체에 피해를 줄 수 있다.

### readResolve나 writeReplace 메서드

- Serializable를 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 가진다면 이 메서드들은 private이 아닌 protected로 선언해야 한다.
- private로 선언한다면 하위 클래스에서 무시된다.

> **클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다.**
>

## 일반적인 구체 클래스

---

전통적으로 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화 되지도 않았다.

하지만 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있어 위험하다.

실제로도 보통의 구체 클래스를 그 내부만 수정해도 이를 확장한 클래스에서 문제가 생기는 경우가 있다.

> **이 문제를 해결하는 가장 좋은 방법은 “상속용으로 설계하지 않는 클래스는 상속을 금지”하는 것이다.**
>

### 상속을 금지하는 방법

1. 둘 중 더 쉬운 쪽은 클래스를 final로 선언하자.
2. 모든 생성자를 private나 package-private로 선언하고 public 정적 팩터리를 만들어 주자. (이 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 준다.)

### 상속을 꼭 허용해야 한다면

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다. 이런 경우에 상속을 꼭 허용해야겠다면 아래 방법을 사용하자

- 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남겨라.

재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽하게 제거하라는 것이다. 이렇게 하면 상속해도 그리 위험하지 않은 클래스를 만들 수 있다.

## 핵심정리

---

> 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그러지 않은면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오작동하게 만들 수 있다. 다른이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.
>