# Item 84 - 프로그램의 동작을 스레드 스케줄러에 기대지 말라

> 작성자: 워니

## 목차
- **잘 작성된 프로그램은, 스레드 스케줄러에 영향을 받지 않는다.**  
- **견고하고 이식성 좋은 프로그램 작성하기**
- **피해야 할 상황**  
- **📌 정리**

---

### 잘 작성된 프로그램은, 스레드 스케줄러에 영향을 받지 않는다.

> 💡 **스레드 스케줄러란?**

![image](https://github.com/Poin-Book/2023.09-Effective_Java/assets/116738827/9b6fa332-cc57-4097-8abb-e0e8110746d1)

- 스레드의 실행 시점을 관리하는 역할을 한다.
    - 언제 실행 가능한 상태로 움직여야 할지
    - 언제 실행 중인 상태를 종료해야 할지
    - 종료했을 때 스레드를 어디로 보내야 할지
      
- 제한된 자원을 여러 프로세스가 효율적으로 사용하도록 다양한 정책(Policy)을 가지고 할당한다.
- 여러 스레드가 실행 중일 때, OS의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할 지를 정한다.
- 정상적인 운영체제인 경우 공정하게 처리하지만, 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다.

➡️ 그렇기에 스케줄링 정책에 기대지 않는 프로그램을 만들어야 한다. 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

```
// 이식이 어려운 프로그램을 만들고 있는 👽
👽 : 이 프로그램은 A 스케줄링 정책에 맞춰 작성해야지! macOS 기반에서 A 정책은 우선순위가 높으니까 제대로 돌아갈거야!

// 이식성이 좋은 프로그램을 만들고 있는 🐰
🐰 : 프로세스 수가 n개니까 스레드 개수가 너무 많아지지 않게 조절해야겠다!
     (기본 최대값은 프로세스당 250개의 스레드)
```

---

### 견고하고 이식성 좋은 프로그램 작성하기

> 🤔 그럼 어떻게 해야 **스케줄링에 기대지 않는 좋은 프로그램**을 만들 수 있을까? 

#### 1️⃣ 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 한다.

스레드가 많을수록 스레드 스케줄러는 스케줄링을 위해 필요한 고민의 양이 늘어날 수 밖에 없고, 이런 경우 스케줄링 정책에 따라 변화의 폭이 클 수 밖에 없다.  
그렇기에 스레드의 평균 숫자를 줄일수록 스케줄러가 스케줄링을 편하게 할 수 있고, 스케줄링 정책이 상이한 플랫폼 간에도 큰 차이가 발생하지 않는다.  

#### _실행 가능한 스레드 수를 적게 유지하는 주요 기법은 다음과 같다._
- 전체 스레드 수에서 각각의 스레드가 **작업 완료 후 다음 일이 생길 때까지 대기**하도록 하는 것이다.
- 즉, **스레드가 당장 처리해야 할 작업이 없다면 실행되지 않도록** 해야한다.

#### 2️⃣ 실행 준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록 한다.

---

### 피해야 할 상황

#### 1️⃣ 스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 안 된다.
_(= 즉, 공유 객체가 바뀔 때까지 쉬지 않고 검사하면 안 된다.)_

> 💡 **바쁜 대기란?**

원하는 자원을 얻기 위해 기다리는 것이 아니라 권한을 얻을 때까지 확인하는 것  
_(권한 획득을 위해 많은 CPU를 낭비한다는 단점이 존재함)_

```
바쁜 대기(영어: busy waiting 또는 spinning)란 어떠한 특정 공유자원에 대하여 두 개 이상의 프로세스나 스레드가 그 이용 권한을 획득하고자 하는 동기화 상황에서 그 권한 획득을 위한 과정에서 일어나는 현상이다.  
대부분의 경우에 스핀락(Spin-lock)과 이것을 동일하게 생각하지만, 엄밀히 말하자면 스핀락이 바쁜 대기 개념을 이용한 것이다.

https://ko.wikipedia.org/wiki/%EB%B0%94%EC%81%9C_%EB%8C%80%EA%B8%B0
```

- 바쁜 대기는 스레드 스케줄러의 변덕에 취약하다.
- 프로세서에도 부담을 주기 때문에 다른 작업이 실행될 기회를 빼앗게 된다.  

⇒ 성능과 이식성이 떨어진다.

##### 바쁜 대기 버전 CountDownLatch 구현
- 기다리는 스레드가 공유 자원을 사용할 수 있는지 없는지 계속해서 무한 루프를 돌면서 조건문을 체크하는 방식

``` java
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0) {
            throw new IllegalArgumentException(count + " < 0");
        }
        this.count = count;
    }

    public void await() {
        while (true) { // 계속해서 반복하며 검사하는 바쁜 대기 코드
            synchronized (this) {
                if (count == 0) {
                    return;
                }
            }
        }
    }

    public synchronized void countDown() {
        if (count != 0) {
            count--;
        }
    }
}
```

#### 2️⃣ `Thread.yield`에 의존하면 안 된다.

> 💡 **`Thread.yield`란?**

다른 스레드에게 실행을 양보하는 메서드로, 실행 중인 스레드를 RUNNABLE (실행 대기) 상태로 바꾼다.

- 이식성이 좋지 않고, 테스트할 수단도 없고, 오히려 느려질 가능성도 있다. 
- 차라리 애플리케이션 구조를 바꿔 위에서 언급했던 것처럼 동시에 실행 가능한 스레드 수가 적어지도록 조치하는게 올바른 방법이다.

⇒ 특정 스레드가 다른 스레드과 비교해 CPU 시간을 충분히 얻지 못하여 간신히 돌아가는 프로그램을 볼 때, `Thread.yield`를 사용해 문제를 고쳐보려는 마음을 버려야 한다.

```
ex). 🐶 : A 스레드에 비해 B 스레드는 CPU 시간이 적으니까, yield()를 사용해서 시간을 조절하자!
```

#### 3️⃣ Thread Priority에 의존하면 안 된다.

특정 스레드의 CPU 점유율 높이기와 같은 상황에서 스레드 우선순위를 조절하는 방법도 생각할 수 있겠지만 역시 좋지 않다.

```
ex). 🐶 : 스레드 스케줄링 전략은 우선순위에 따라 바뀌니까 우선순위를 조절해야겠다!
```

- 스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성에 속한다.
- 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수는 있다.
- 그러나 거의 동작하지 않는 프로그램을 _"고치기 위해"_ 사용하면 절대 안 된다.  
  ⇒ 진짜 원인을 찾아 수정하자.

---

### 📌 정리
- 프로그램의 동작을 스레드 스케줄러에 기대지 말자. 이는 견고성과 이식성을 모두 해치는 행위이다.
- `Thread.yield`와 Thread Priority에 의존해서도 안 된다. 이 기능들은 스레드 스케줄러에서 제공하는 힌트일 뿐이다.
  절대 프로그램을 수리할 목적으로 사용해서는 안 된다.
  
