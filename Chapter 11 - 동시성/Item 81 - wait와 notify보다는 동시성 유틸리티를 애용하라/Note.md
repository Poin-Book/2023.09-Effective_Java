# ****wait와 notify보다는 동시성 유틸리티를 애용하라****

> 작성자: 피터
>

고수준의 동시성 유틸리티가 Java5에서 도입되면서 wait와 notify를 사용해야 할 이유가 많이 줄었다.

wait와 notify는 올바르게 사용하기 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.

## wait&notify

자바의 멀티스레딩 환경에서 사용하는 메커니즘이다. 객체의 lock을 사용하여 스레드간 동기화를 달성하는데 사용된다. 스레드 간의 상호 작용과 조건 기반의 대기/통지를 위해 사용된다. 

### wait()

wiat() 메소드는 객체의 모니터(lock)을 해제하고 현재 스레드를 대기 상태로 만든다. 다른 스레드가 모니터를 획득하고 특정 조건을 충족시킬 때까지 대기한다. 

### notify(), notifyAll()

notify() 메소드는 대기 중인 스레드 중 하나를 임의로 활성화 시킨다. 이 메소드를 호출하면, 대기 상태에 있는 스레드 중 하나가 모니터를 다시 획득할 수 있는 기회를 얻는다. 

notifyAll() 메소드는 모든 대기 중인 스레드를 활성화 시킨다.  대기 중인 모든 스레드가 모니터를 획득하기 위해 경쟁하게 만든다.

## 동시성 유틸리티

java.util.concurrent 동시성 유틸리티는 **실행자 프레임워크, 동시성 컬렉션, 동기화 장치** 이렇게 세 범주로 나눌 수 있다.

### **실행자 프레임워크**

자바의 실행자 프레임워크는 스레드 관리 및 실행을 위한 고수준의 유틸리티를 제공한다.  스레드 생성과 관리를 추상화하여 개발자가 멀티스레딩을 보다 쉽게 구현할 수 있게 한다.

### **동시성 컬렉션**

동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션으로, 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다. 따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을  추가로 사용하면 오히려 속도가 느려진다.

### **동기화 장치**

동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 해서 서로의 작업을 조율할 수 있게 해 준다. 대표적인 동기화 장치로는 CountDownLatch와 Semaphore가 있으며 가장 강력한 동기화 장치는 Phaser다. 이 외에도 CyclicBarrier와 Exchanger가 있지만 위의 두 개의 동기화 장치보다는 덜 쓰인다.

## **wait와 notify를 사용해야할 때**

동시성 유틸리티를 사용하는게 옳지만, 어쩔 수 없이 레거시 코드를 다뤄야할 때도 있다.

### wait

wait 메소드는 스레드가 어떤 조건이 충족되기를 기다리게 할 때 사용하고 락 객체의 wait 메소드는 반드시 그 객체를 잠근 동기화 영역 안에서 호출해야한다.

### notify

일반적으로 notify()보다 notifyAll()을 사용하는 것이 안전하다.

## 정리

레거시코드를 다루는게 아니라면, 즉 코드를 새로 작성한다면 wait과 notify를 사용할 이유가 없다. 만약 사용해야 한다면 wait은 항상 while 문 안에서 호출하도록하며 notify보다는 notifyAll을 사용해야 한다.
