# 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

> 작성자: @destiny3912

## 목차
- [정의하려는 것이 타입이라면 마커 인터페이스를 사용하라](#정의하려는-것이-타입이라면-마커-인터페이스를-사용하라)
  - [목차](#목차)
  - [본문](#본문)
  - [Item 41 정의 하는 것이 타입이라면 마커 인터페이스를 사용하라](#item-41-정의-하는-것이-타입이라면-마커-인터페이스를-사용하라)
    - [1. 마커 인터페이스란](#1-마커-인터페이스란)
    - [2. 마커 인터페이스와 어노테이션](#2-마커-인터페이스와-어노테이션)
    - [3. 그래서 언제 무엇을 써야하는가?](#3-그래서-언제-무엇을-써야하는가)
    - [4. 핵심 정리](#4-핵심-정리)

## 본문

## Item 41 정의 하는 것이 타입이라면 마커 인터페이스를 사용하라

---

### 1. 마커 인터페이스란

> 자신을 구현하는 클래스가 특정 속성을 가지고 있음을 표시해주는 인터페이스
> 
- 아무 메서드도 담고있지 않다
- 예시 → Serializable 인터페이스
    - 자신을 구현한 클래스의 인스턴스는 ObjectOutputStream을 통해서 write가 가능하다 (직렬화가 가능하다)

### 2. 마커 인터페이스와 어노테이션

> 통념: 마커 인터페이스는 어노테이션에 비해 구식이고 좋지않다
> 
- 하지만 이는 사실이 아니다!

> 다음의 부분에서는 인터페이스가 더 낫다
> 
1. 구현한 클래스의 인스턴스를 구분하는 타입으로 사용이 가능한가?
- 마커 인터페이스는 가능하나 어노테이션은 그렇지 않다.
- 인터페이스는 엄연한 타입이므로 컴파일 타임에 오류를 잡아낼 수 있다.
- 예시 → 만약 어노테이션으로 사용 했다면
    - Serializable은 마커 인터페이스를 보고 직렬화 가능한지 판단
    - 당연히 Serializable 인터페이스를 구현했을거라고 가정하고 들어감
    - 따라서 ObjectOutputStream.writeObject 메서드는 Object 객체를 받는 메서드
    - 여기에 Serializable이 아닌 객체를 넘긴다면 런타임에야 문제를 확인이 가능
1. 적용 대상을 정밀하게 지정이 가능한가?
    - 적용 대상(@Target)을 ElementType.TYPE으로 선언한 어노테이션은 모든 타입에 부착이 가능
        - 클래스, 인터페이스, 열거 타입, 어노테이션
        - 부착할 수 있는 타입의 세밀한 제어가 불가하다는 의미이다.
    - 가정을 해보자
        - 마커를 특정 인터페이스를 구현한 클래스에 사용하고 싶다.
        - 그렇다면 인터페이스로 정의하여 마킹하고 싶은 클래스에서만 구현하면 된다.
        - 그렇게 하면 마킹된 타입은 자동으로 그 인터페이스의 하위 타입임이 보장된다.
    - 예시들 들어보자 → Set 인터페이스
        
        > 일종의 제약이 있는 마커 인터페이스로 간주 가능
        > 
        - Set은 Collection의 하위 타입에만 적용 가능
        - 따라서 Collection이 정의한 메서드 이외에는 추가적인 메서드가 없음
        - 근데 왜 마커 인터페이스로 보지 않느냐면
            - add, equals, hashCode 등등 Collection의 메서드 일부의 규칙을 수정했지 때문이다.
        - 다만
            - 특정 인터페이스의 하위 타입에만 적용이 가능하며
            - 아무런 규약에 손을대지 않은 마커 인터페이스는 있을 수 있다.
        - 이러한 마커 인터페이스는
            - 객체의 특정 부분을 불변식으로 처리하거나
            - 해당 타입의 인터페이스는 다른 클래스의 특정 메서드가 처리를 할 수 있다는 것을 명시하는 용도로 사용
            - 예를 들어서
                - Serializable 인터페이스가 ObjectOutputStream이 처리 가능한 인터페이스임을 명시

> 반대로 어노테이션이 인터페이스보다 나은 점은 다음과 같다
> 
- 어노테이션 시스템의 지원을 받는다.
- 따라서 Spring같은 어노테이션 기반 프레임워크에서는 어노테이션을 쓰는게 일관성에 있어 좋다.

### 3. 그래서 언제 무엇을 써야하는가?

1. 확실한 것
    - 모듈, 패키지, 필드, 지역변수 같은 클래스와 인터페이스 외의 요소들에 마킹할때는 강제로 어노테이션을 써야함
        - 왜? → 저기에는 인터페이스를 구현할 수가 없으니까
2. 클래스나 인터페이스에 적용할 때
    - 다음의 조건을 생각해 보자
        
        > 마킹이 된 객체를 매개변수로 받는 메서드가 존재하는가?
        > 
        - 그렇다
            - 마커 인터페이스
            - 매개변수를 잘못 넘겼을때 컴파일 타임에 오류를 잡아내는 것이 가능
        - 아니다
            - 마커 어노테이션
3. 어노테이션 사용을 기반으로하는 프레임워크
    
    > 그냥 어노테이션을 쓰자
    > 

### 4. 핵심 정리

- 마커 인터페이스와 어노테이션은 각자의 역할이 있다
    - 마커 인터페이스
        - 새로 추가하는 메서드 없이 단지 타입 정의가 목적이다
    - 마커 어노테이션
        - 클래스나 인터페이스 외의 요소에 마킹해야함
        - 어노테이션을 기반으로하는 프레임워크
- 적용 대상이 ElementType.TYPE인 마커 어노테이션을 작성하고 있다면
    - 다음의 질문을 날려보자
        
        > 마킹이 된 객체를 매개변수로 받는 메서드가 존재하는가?
        > 
    - 그 다음 어노테이션인지 인터페이스인지 결정하자
