# Item 70 - 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

> 작성자: 다나

## 목차
- 예외의 4가지 종류
- 예외별 사용 지침
  - 검사 예외
  - 비검사 예외
- 프로그래밍 오류
- 만들면 안 되는 예외
- 핵심 정리
## **예외의 4가지 종류**

> 예외는 `throwable` 타입이라고 한다.
> 

예외는 검사, 비검사 예외가 있으며 하위 예외로 런타임 예외와 에러가 있고 각각의 목적이 있다.

- 검사 예외 (Checked Exception)
- 비검사 예외 (Unchecked Exception)
    - 런타임 예외 (Runtime Exception)
    - 에러 (Error)

검사 예외와 비검사 예외는 예외 처리를 강제하냐 아니냐의 차이가 있다.

## **예외별 사용 지침**

- `검사 예외`: 호출하는 쪽에서 복구하리라 여겨지는 상황에 사용한다.
    - `catch` 로 복구하거나 밖으로 퍼트려(`throws`) 복구할 가능성이 있다.
    - 복구할 가능성이 있으므로, 복구에 도움이 되는 여러 메서드들을 제공해주면 좋다.
        - ex) 통장 잔고가 부족하다면, 얼마가 부족한지 알려주면 예외 복구에 도움이 된다. ATM기에서 그냥 잔액이 부족하다고 알리기보다 만원을 인출하기 위해서 3천원이 모자르다고 알려주면, 고객은 3천원을 더 입금하고 만원을 출금할 수 있다.
- `비검사 예외(런타임 예외, 에러)`: 복구가 불가능하거나 더 실행해봐야 실이 많을 때 사용한다.
    - ex) 비즈니스 로직 실행 도중 일어나는 `NullPointerException` 은 보통 로직을 바꾸고 다시 컴파일하지 않는 이상 해결할 수 없다.

## **프로그래밍 오류의 경우**

- `런타임 예외`를 사용한다.
- 이를테면, 배열에서 잘못된 인덱스에 접근한 경우 혹은 `NullPointerException` 등이 있다.
- 복구 가능 여부가 불투명하면 비검사 예외를 선택하는 편이 좋다.
- `Error` 클래스의 의도는 JVM 수준에서 발생하는 심각하고 복구할 수 없는 문제를 나타내는데 사용한다.
    - JVM 에서 자원 부족, 불변식 깨짐 등 명확하게 작업 수행이 불가능할 때 발생한다.
    - `Error` 클래스의 의도는 명확하므로 `Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제하자.
        - **즉, 비검사 예외의 경우는 `RuntimeException`만 상속해서 만들라는 것이다.**

> 이 경우 문제가 되는 부분은 복구가 가능한지 불명확한 경우가 많다는 것이다. 자원 부족의 경우엔 추후에 시간만 지나면 해결될 가능성이 있지만, 시간이 지나도 자원 점유가 해소되지 않으면, 복구가 불가능할 것이다. 이 부분은 잘 생각해보아야 한다.
> 

### **만들면 안되는 예외**

- `Exception`, `RuntimeException`, `Error` 를 상속하지 않는 `throwable` 은 만들지 않는 것이 좋다.
    - 예외는 예외를 일으킨 상황에 대한 정보를 주려 존재한다.
        - 그리고 그것을 위해 특정한 메소드를 사용한다.
        - 다른 클래스를 상속하는 예외는 해당 메서드를 직접 작성해야 한다.
        - 이러한 메서드가 없으면 오류 메서드를 직접 파싱해 정보를 빼내야 한다.

## **핵심 정리**

- 복구할 수 있다면 검사 예외 (Checked Exception)
- 복구할 수 없다면 비검사 예외 (Unchecked Exception)
- 확실하지 않다면 비검사 예외 (Unchecked Exception)
- 검사 예외도 아니고 런타임 예외도 아닌 `throwable` 은 정의하지 말자.
- 검사 예외라면 복구에 필요한 정보도 제공해주자
    - ex) 어떤 조치를 취하면 에러가 사라지는지

